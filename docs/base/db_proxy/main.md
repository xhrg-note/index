## db-proxy

这里讲的db-proxy表示分库分表。 根据部署接口可以分为2类
* sdk-proxy
* 独立节点的proxy

随着业务的增长，单表数据超过百万级，一旦到千万级，mysql查询就会很慢。读写分离的原因则很简单。

## db-proxy的多重模式

* sdk-proxy。这种方式是把分库分表，读写分离的逻辑全部放在sdk中做。缺点是，sdk升级复杂，举个例子。你在sdk中增加了一些功能，但是这些功能业务不需要，那么他们肯定不愿意升级。但是有一种场景，就是你增加了一些监控数据类，这些功能，对业务来说，无所谓，对基础部门的同事来说确很重要。这个时候，就是一个矛盾点。还有一个缺点是，分库分表的复杂逻辑并不简单，如果用java开发了一套代码，现在golang的项目要用怎么办？没办法适配多语言。


* 集中式的proxy。集中式的分库分配是启动一个节点，这个节点会伪装成mysql-server，接收请求，做sql解析，然后路由到不同的mysql。这种部署方案，可以很好的避免多语言和sdk升级的问题。但是这种方案也不是完美的，举个例子proxy部署了多台，其中一台挂了。这个时候业务的sdk，要不要把sql请求转发到其他节点。业务的sql要不要重试。业务的sdk要不要反馈mock数据。市面上的mysql驱动大多数不能支持这种功能。有一个办法和传统直连mysql一样。就是使用虚拟ip，ip漂移的方式，但是那种方式，也是需要人工介入的方式。


* 本地代理+集中式代理。这种方案也是我觉得最好的方案。本地客户端把容错，路由转发的所有逻辑，放在主机级别的代理上，类似于service mesh的方式。而把分库分表，读写分离的逻辑放在集中式的proxy中。这样本地代理，依然是很少升级，集中式的代理可能升级频繁。而且可以动态控制许多的本地节点的流量怎么去路由。
